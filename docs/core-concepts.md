# Core Concepts

Note: this document was adapted 100% from Clojure's Ring [Concepts](https://github.com/ring-clojure/ring/wiki/Concepts) document.

A web application developed with lmug consists of four components:

* Handler
* Request
* Response
* Middleware

## Handlers

Handlers are functions that define your web application. **Synchronous** handlers take one argument, a map representing a HTTP request, and return a map representing the HTTP response.

For example:

```lisp
(defun what-is-my-ip (req)
  #m(status 200
     headers #m(content-type #"text/plain")
     body (mref req 'remote-addr)))
```

This function returns a map that lmug can translate into an [HTTP response](https://github.com/lfe-http/http). The response returns a plain text file that contains the IP address that was used to access the web application.

Handlers may also be **asynchronous**. Handlers of this type take three arguments: the request map, a response callback and an exception callback.

For example:

```lisp
(defun what-is-my-ip (req respond-fn)
  (funcall respond-fn #m(status 200
                         headers #m(content-type #"text/plain")
                         body (mref req 'remote-addr))))
```

Supporting both is done with by including both arities in your code:

```lisp
(defun what-is-my-ip (req)
  #m(status 200
     headers #m(content-type #"text/plain")
     body (mref req 'remote-addr)))

(defun what-is-my-ip (req respond)
  (funcall respond #m(status 200
                      headers #m(content-type #"text/plain")
                      body (mref req 'remote-addr))))

```

All official lmug middleware supports both types of handler, but for most purposes synchronous handlers are sufficient.

The handler function can be converted into a web application through a variety of different methods which will be covered in the next section.

## Requests

As previously mentioned, HTTP requests are represented by LFE HTTP maps. There are a number of standard keys that will always exist, but requests can (and often do) contain custom keys added by middleware.

The standard keys are:

* `body`: A binary value for the request body.
* `headers` An LFE map of lowercase header name strings to corresponding header value strings.

* `method`: The HTTP request method, which is one of `GET`, `HEAD`, `OPTIONS`, `PATCH`, `PUT`, `POST`, or `DELETE`.
* `path-segments`: A list of elements of the path (parsed from `'(url-parsed path)`).
* `query-parsed`: A map of key/value pairs (parsed from `'(url-parsed query)`).
* `remote-addr`: The IP address of the client or the last proxy that sent the request.
* `url`: The full URL of the request
* `url-parsed`: All the parts of the URL parsed as an LFE map; includes `fragment`,`host`, `password` (parsed from `userinfo`), `path`, `port`, `query`, `scheme`, `user` (parsed from `userinfo`).
* `version`: The version of the HTTP protocol being used.

## Responses

The response map is created by the handler, and contains three keys:

* `status`: The HTTP status code, such as 200, 302, 404 etc.
* `headers`: An LFE map of HTTP header names to header values. The keys are atoms and the values are bitstrings.
* `body`: A binary representation of the response body.

## Middleware

Middleware are higher-level functions that add additional functionality to handlers. The first argument of a middleware function should be a handler, and its return value should be a new handler function that will call the original handler.

Here is a simple example:

```lisp
(defun wrap-content-type (handler content-type)
  (lambda (request)
    (let ((response (handler request)))
      (clj:assoc-in response #m(headers content-type) content-type))))
```

This middleware function adds a "Content-Type" header to every response generated by the handler. It will only work with synchronous handlers, but we can extend it to support both synchronous and asynchronous handlers:

```clojure
(defn content-type-response [response content-type]
  (assoc-in response [:headers "Content-Type"] content-type))

(defn wrap-content-type [handler content-type]
  (fn
    ([request]
      (-> (handler request) (content-type-response content-type)))
    ([request respond raise]
      (handler request #(respond (content-type-response % content-type)) raise))))
```

Notice that we factored out the common code that changes the response into its own function. By convention, if `wrap-foo` is our middleware function, then `foo-request` and `foo-response` are helper functions that operate on the request and response.

Once this middleware is written, it can be applied to a handler:

```clojure
(def app
  (wrap-content-type handler "text/html"))
```

This defines a new handler, `app` that consists of the handler `handler` with the `wrap-content-type` middleware applied.

The threading macro (`->`) can be used to chain middleware together:

```clojure
(def app
  (-> handler
      (wrap-content-type "text/html")
      (wrap-keyword-params)
      (wrap-params)))
```

Middleware is used often in lmug, and is used to provide much of its functionality beyond handling raw HTTP requests. Parameters, sessions, and file uploading are all handled by middleware in the lmug standard library.

Note: middleware runs from bottom to top, and if any middleware creates a response, that will short-circuit and the middleware above will not be called.

[Next Page - Creating responses](https://github.com/ring-clojure/ring/wiki/Creating-responses)
